{
    "docs": [
        {
            "location": "/",
            "text": "Home\n\u00b6\n\n\nRoact is a \ndeclarative\n Lua UI library similar to Facebook's \nReact\n. It exposes a very similar API and implements nearly identical semantics.\n\n\nThis documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect, \nopen an issue on GitHub\n!\n\n\n\n\nInfo\n\n\nThis documentation assumes some familiarity with Lua. If you're new to Lua, \nProgramming in Lua\n by Roberto Ierusalimschy\n is a good introduction, and the first edition (for Lua 5.0) is available online for free.",
            "title": "Home"
        },
        {
            "location": "/#home",
            "text": "Roact is a  declarative  Lua UI library similar to Facebook's  React . It exposes a very similar API and implements nearly identical semantics.  This documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect,  open an issue on GitHub !   Info  This documentation assumes some familiarity with Lua. If you're new to Lua,  Programming in Lua  by Roberto Ierusalimschy  is a good introduction, and the first edition (for Lua 5.0) is available online for free.",
            "title": "Home"
        },
        {
            "location": "/guide/installation/",
            "text": "Installation\n\u00b6\n\n\nThere are two supported ways to get started with Roact.\n\n\nFor our examples, we'll install \nRoact\n to \nReplicatedStorage\n. In practice, it's okay to install Roact anywhere you want!\n\n\nMethod 1: Installation Script (Roblox Studio)\n\u00b6\n\n\n\n\nDownload the latest release from the \nGitHub releases page\n.\n\n\nUse the 'Run Script' menu (located in the Test tab) to locate and run this script.\n\n\nFollow the installer's instructions to put Roact into \nReplicatedStorage\n\n\n\n\nMethod 2: Rojo\n\u00b6\n\n\n\n\nInstall \nRojo\n, a file sync plugin\n\n\nPut Roact into your project:\n\n\nCopy the \nlib\n folder into your project, and rename it to \nRoact\n\n\nAlternatively, add a Git submodule to your project\n\n\n\n\n\n\nAdd a partition in Rojo to put Roact into \nReplicatedStorage.Roact",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#installation",
            "text": "There are two supported ways to get started with Roact.  For our examples, we'll install  Roact  to  ReplicatedStorage . In practice, it's okay to install Roact anywhere you want!",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#method-1-installation-script-roblox-studio",
            "text": "Download the latest release from the  GitHub releases page .  Use the 'Run Script' menu (located in the Test tab) to locate and run this script.  Follow the installer's instructions to put Roact into  ReplicatedStorage",
            "title": "Method 1: Installation Script (Roblox Studio)"
        },
        {
            "location": "/guide/installation/#method-2-rojo",
            "text": "Install  Rojo , a file sync plugin  Put Roact into your project:  Copy the  lib  folder into your project, and rename it to  Roact  Alternatively, add a Git submodule to your project    Add a partition in Rojo to put Roact into  ReplicatedStorage.Roact",
            "title": "Method 2: Rojo"
        },
        {
            "location": "/guide/hello-roact/",
            "text": "Hello, Roact!\n\u00b6\n\n\n\n\nInfo\n\n\nThese examples asssumes that you've successfully \ninstalled Roact\n into \nReplicatedStorage\n!\n\n\n\n\nAdd a new \nLocalScript\n object to \nStarterPlayer.StarterPlayerScripts\n either in Roblox Studio, or via Rojo:\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \napp\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n    \nHelloWorld\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n        \nText\n \n=\n \n\"Hello, Roact!\"\n\n    \n})\n\n\n})\n\n\n\nRoact\n.\nreify\n(\napp\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n)\n\n\n\n\n\nWhen you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!",
            "title": "Hello, Roact!"
        },
        {
            "location": "/guide/hello-roact/#hello-roact",
            "text": "Info  These examples asssumes that you've successfully  installed Roact  into  ReplicatedStorage !   Add a new  LocalScript  object to  StarterPlayer.StarterPlayerScripts  either in Roblox Studio, or via Rojo:  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   app   =   Roact . createElement ( \"ScreenGui\" ,   {},   { \n     HelloWorld   =   Roact . createElement ( \"TextLabel\" ,   { \n         Size   =   UDim2 . new ( 0 ,   400 ,   0 ,   300 ), \n         Text   =   \"Hello, Roact!\" \n     })  })  Roact . reify ( app ,   Players . LocalPlayer . PlayerGui )   When you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!",
            "title": "Hello, Roact!"
        },
        {
            "location": "/guide/elements/",
            "text": "Elements\n\u00b6\n\n\nLike React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI.\n\n\nElements describe what you want your UI to look like at a single point in time. They're \nimmutable\n: you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal.\n\n\nYou can create an element using \nRoact.createElement\n -- just pass a Roblox class name as the first argument, and any properties as the second argument!\n\n\nlocal\n \nmyElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n50\n,\n \n0\n,\n \n50\n)\n\n\n})\n\n\n\n\n\nYou can also represent children by passing them to the optional third argument of \ncreateElement\n:\n\n\nlocal\n \nmyElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n50\n,\n \n0\n,\n \n50\n)\n\n\n},\n \n{\n\n    \nSomeChild\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, Roact!\"\n\n    \n})\n\n\n})\n\n\n\n\n\nCreating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call \nRoact.reify\n:\n\n\n-- Create a new Frame object in 'Workspace'\n\n\nlocal\n \nmyHandle\n \n=\n \nRoact\n.\nreify\n(\nmyElement\n,\n \ngame\n.\nWorkspace\n)\n\n\n\n\n\nRoact.reify\n returns a handle that we can later use to update or destroy that object with \nRoact.reconcile\n and \nRoact.teardown\n.\n\n\nChanging What's Rendered\n\u00b6\n\n\nIn order to change the UI that we've created, we need to create a new set of elements and \nreconcile\n the existing tree to match it.\n\n\nReconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time.\n\n\nUsing \nmyHandle\n from above, we can update the size and text of our label:\n\n\n-- Make some new elements that describe what our new UI will look like.\n\n\nlocal\n \nmyNewElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n100\n,\n \n0\n,\n \n50\n)\n\n\n},\n \n{\n\n    \nSomeChild\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, again, Roact!\"\n\n    \n})\n\n\n})\n\n\n\n-- Update our hierarchy to match those elements.\n\n\nmyHandle\n \n=\n \nRoact\n.\nreconcile\n(\nmyHandle\n,\n \nmyNewElement\n)\n\n\n\n\n\n\n\nInfo\n\n\nMost projects using UI don't use \nRoact.reconcile\n and instead change UI using state and lifecycle events, which will be introduced in the next section.\n\n\nRoact.reconcile\n is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact!\n\n\n\n\nUnlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.\n\n\nDestroying the Tree\n\u00b6\n\n\nRoact provides a method called \nRoact.teardown\n that we can use when we're finished with our tree.\n\n\nRoact\n.\nteardown\n(\nmyHandle\n)\n\n\n\n\n\n\n\nWarning\n\n\nOnce \nteardown\n is called, all Roblox Instances get destroyed!\n\n\nTrying to use a handle after it's been passed to \nRoact.teardown\n will result in errors!\n\n\n\n\nIncrementing Counter\n\u00b6\n\n\nUsing what's been covered so far, we can make a simple program that tells you how long it has been running.\n\n\nThis is a complete example that should work when put into a \nLocalScript\n in \nStarterPlayerScripts\n. It assumes Roact has been installed into \nReplicatedStorage\n.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Create a function that creates the elements for our UI.\n\n\n-- Later, we'll use components, which are the best way to organize UI in Roact.\n\n\nlocal\n \nfunction\n \nclock\n(\ncurrentTime\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our initial UI.\n\n\nlocal\n \ncurrentTime\n \n=\n \n0\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nclock\n(\ncurrentTime\n),\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n-- Every second, update the UI to show our new time.\n\n\nwhile\n \ntrue\n \ndo\n\n    \nwait\n(\n1\n)\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n \n+\n \n1\n\n    \nhandle\n \n=\n \nRoact\n.\nreconcile\n(\nhandle\n,\n \nclock\n(\ncurrentTime\n))\n\n\nend\n\n\n\n\n\nIn the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.",
            "title": "Elements"
        },
        {
            "location": "/guide/elements/#elements",
            "text": "Like React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI.  Elements describe what you want your UI to look like at a single point in time. They're  immutable : you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal.  You can create an element using  Roact.createElement  -- just pass a Roblox class name as the first argument, and any properties as the second argument!  local   myElement   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 0 ,   50 ,   0 ,   50 )  })   You can also represent children by passing them to the optional third argument of  createElement :  local   myElement   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 0 ,   50 ,   0 ,   50 )  },   { \n     SomeChild   =   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, Roact!\" \n     })  })   Creating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call  Roact.reify :  -- Create a new Frame object in 'Workspace'  local   myHandle   =   Roact . reify ( myElement ,   game . Workspace )   Roact.reify  returns a handle that we can later use to update or destroy that object with  Roact.reconcile  and  Roact.teardown .",
            "title": "Elements"
        },
        {
            "location": "/guide/elements/#changing-whats-rendered",
            "text": "In order to change the UI that we've created, we need to create a new set of elements and  reconcile  the existing tree to match it.  Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time.  Using  myHandle  from above, we can update the size and text of our label:  -- Make some new elements that describe what our new UI will look like.  local   myNewElement   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 0 ,   100 ,   0 ,   50 )  },   { \n     SomeChild   =   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, again, Roact!\" \n     })  })  -- Update our hierarchy to match those elements.  myHandle   =   Roact . reconcile ( myHandle ,   myNewElement )    Info  Most projects using UI don't use  Roact.reconcile  and instead change UI using state and lifecycle events, which will be introduced in the next section.  Roact.reconcile  is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact!   Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.",
            "title": "Changing What's Rendered"
        },
        {
            "location": "/guide/elements/#destroying-the-tree",
            "text": "Roact provides a method called  Roact.teardown  that we can use when we're finished with our tree.  Roact . teardown ( myHandle )    Warning  Once  teardown  is called, all Roblox Instances get destroyed!  Trying to use a handle after it's been passed to  Roact.teardown  will result in errors!",
            "title": "Destroying the Tree"
        },
        {
            "location": "/guide/elements/#incrementing-counter",
            "text": "Using what's been covered so far, we can make a simple program that tells you how long it has been running.  This is a complete example that should work when put into a  LocalScript  in  StarterPlayerScripts . It assumes Roact has been installed into  ReplicatedStorage .  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Create a function that creates the elements for our UI.  -- Later, we'll use components, which are the best way to organize UI in Roact.  local   function   clock ( currentTime ) \n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our initial UI.  local   currentTime   =   0  local   handle   =   Roact . reify ( clock ( currentTime ),   PlayerGui ,   \"Clock UI\" )  -- Every second, update the UI to show our new time.  while   true   do \n     wait ( 1 ) \n\n     currentTime   =   currentTime   +   1 \n     handle   =   Roact . reconcile ( handle ,   clock ( currentTime ))  end   In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.",
            "title": "Incrementing Counter"
        },
        {
            "location": "/guide/components/",
            "text": "Components\n\u00b6\n\n\nComponents are encapsulated, reusable pieces of UI that you can combine to build a complete UI.\n\n\nComponents accept inputs, known as \nprops\n, and return elements to describe the UI that should represent those inputs.\n\n\nFunctional and Stateful Components\n\u00b6\n\n\nComponents come in two flavors in Roact, \nfunctional\n and \nstateful\n.\n\n\nFunctional components are the simplest: they're just functions that accept props as their only argument, and return some elements.\n\n\nlocal\n \nfunction\n \nGreeting\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\n\n\nRoact also has \nstateful\n components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section.\n\n\nYou can create a stateful component by calling \nRoact.Component:extend\n and passing in the component's name.\n\n\nlocal\n \nGreeting\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Greeting\"\n)\n\n\n\nfunction\n \nGreeting\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nself\n.\nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\n\n\nUsing Components\n\u00b6\n\n\nIn our previous examples, we passed strings to \nRoact.createElement\n to create elements that represented Roblox Instances.\n\n\nWe can also pass our custom components to create elements that represent them:\n\n\nlocal\n \nhello\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n    \nname\n \n=\n \n\"Rick James\"\n\n\n})\n\n\n\n\n\nThe \nname\n value is passed to our component as props, which we can reference as the \nprops\n argument in our functional component or \nself.props\n in our stateful component.\n\n\nComponents in Components\n\u00b6\n\n\nComponents are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components!\n\n\nlocal\n \nfunction\n \nGreeting\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nfunction\n \nGreetEveryone\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{\n\n        \nLayout\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n),\n\n\n        \nHelloJoe\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n            \nname\n \n=\n \n\"Joe\"\n\n        \n}),\n\n\n        \nHelloMary\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n            \nname\n \n=\n \n\"Mary\"\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n\n\nApplications built using Roact usually have one component at the top of the tree, and include all other pieces as children.\n\n\nIncrementing Counter, Part Two\n\u00b6\n\n\nWe can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Create a functional component that represents our UI\n\n\nlocal\n \nfunction\n \nClock\n(\nprops\n)\n\n\n    \nlocal\n \ncurrentTime\n \n=\n \nprops\n.\ncurrentTime\n\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our initial UI.\n\n\nlocal\n \ncurrentTime\n \n=\n \n0\n\n\n\nlocal\n \nclockElement\n \n=\n \nRoact\n.\ncreateElement\n(\nClock\n,\n \n{\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n\n\n})\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nclockElement\n,\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n\n-- Every second, update the UI to show our new time.\n\n\nwhile\n \ntrue\n \ndo\n\n    \nwait\n(\n1\n)\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n \n+\n \n1\n\n\n    \nhandle\n \n=\n \nRoact\n.\nreconcile\n(\nhandle\n,\n \nRoact\n.\ncreateElement\n(\nClock\n,\n \n{\n\n\n        \ncurrentTime\n \n=\n \ncurrentTime\n\n\n    \n}))\n\n\nend",
            "title": "Components"
        },
        {
            "location": "/guide/components/#components",
            "text": "Components are encapsulated, reusable pieces of UI that you can combine to build a complete UI.  Components accept inputs, known as  props , and return elements to describe the UI that should represent those inputs.",
            "title": "Components"
        },
        {
            "location": "/guide/components/#functional-and-stateful-components",
            "text": "Components come in two flavors in Roact,  functional  and  stateful .  Functional components are the simplest: they're just functions that accept props as their only argument, and return some elements.  local   function   Greeting ( props ) \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   props . name \n     })  end   Roact also has  stateful  components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section.  You can create a stateful component by calling  Roact.Component:extend  and passing in the component's name.  local   Greeting   =   Roact . Component : extend ( \"Greeting\" )  function   Greeting : render () \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   self . props . name \n     })  end",
            "title": "Functional and Stateful Components"
        },
        {
            "location": "/guide/components/#using-components",
            "text": "In our previous examples, we passed strings to  Roact.createElement  to create elements that represented Roblox Instances.  We can also pass our custom components to create elements that represent them:  local   hello   =   Roact . createElement ( Greeting ,   { \n     name   =   \"Rick James\"  })   The  name  value is passed to our component as props, which we can reference as the  props  argument in our functional component or  self.props  in our stateful component.",
            "title": "Using Components"
        },
        {
            "location": "/guide/components/#components-in-components",
            "text": "Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components!  local   function   Greeting ( props ) \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   props . name \n     })  end  local   function   GreetEveryone () \n     return   Roact . createElement ( \"ScreenGui\" ,   { \n         Layout   =   Roact . createElement ( \"UIListLayout\" ), \n\n         HelloJoe   =   Roact . createElement ( Greeting ,   { \n             name   =   \"Joe\" \n         }), \n\n         HelloMary   =   Roact . createElement ( Greeting ,   { \n             name   =   \"Mary\" \n         }) \n     })  end   Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children.",
            "title": "Components in Components"
        },
        {
            "location": "/guide/components/#incrementing-counter-part-two",
            "text": "We can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted.  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Create a functional component that represents our UI  local   function   Clock ( props )       local   currentTime   =   props . currentTime  \n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our initial UI.  local   currentTime   =   0  local   clockElement   =   Roact . createElement ( Clock ,   {       currentTime   =   currentTime  })  local   handle   =   Roact . reify ( clockElement ,   PlayerGui ,   \"Clock UI\" )   -- Every second, update the UI to show our new time.  while   true   do \n     wait ( 1 ) \n\n     currentTime   =   currentTime   +   1       handle   =   Roact . reconcile ( handle ,   Roact . createElement ( Clock ,   {           currentTime   =   currentTime       }))  end",
            "title": "Incrementing Counter, Part Two"
        },
        {
            "location": "/guide/state-and-lifecycle/",
            "text": "State and Lifecycle\n\u00b6\n\n\nIn the previous section, we talked about using components to create reusable chunks of state, and introduced \nfunctional\n and \nstateful\n components.\n\n\nStateful components do everything that functional components do, but have the addition of mutable \nstate\n and \nlifecycle methods\n.\n\n\nState\n\u00b6\n\n\n\n\nInfo\n\n\nThis section is incomplete!\n\n\n\n\nLifecycle Methods\n\u00b6\n\n\nStateful components can provide methods to Roact that are called when certain things happen to a component instance.\n\n\nLifecycle methods are a great place to send off network requests, measure UI (\nwith the help of refs\n), wrap non-Roact components, and produce other side-effects.\n\n\nMounting:\n\n\n\n    \ninit\n\n    \n\u279d\n\n    \nrender\n\n    \n\u279d\n\n    \ndidMount\n\n\n\n\n\nUpdating:\n\n\n\n    \nshouldUpdate?\n\n    \n\u279d\n\n    \ngetDerivedStateFromProps\n\n    \n\u279d\n\n    \nwillUpdate\n\n    \n\u279d\n\n    \nrender\n\n    \n\u279d\n\n    \ndidUpdate\n\n\n\n\n\nUnmounting:\n\n\n\n    \nwillUnmount\n\n\n\n\n\nIncrementing Counter, Part Three\n\u00b6\n\n\nBuilding on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use \nsetState\n to trigger a re-render instead of \nRoact.reconcile\n.\n\n\nGenerally, this ticking clock demonstrates how many stateful components are structured in Roact.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \nClock\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Clock\"\n)\n\n\n\nfunction\n \nClock\n:\ninit\n()\n\n    \n-- In init, you should assign to 'state' directly.\n\n    \n-- Use this opportunity to set any initial values.\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \ncurrentTime\n \n=\n \n0\n\n    \n}\n\n\nend\n\n\n\n-- This render function is almost completely unchanged from the first example.\n\n\nfunction\n \nClock\n:\nrender\n()\n\n    \n-- As a convention, we'll pull currentTime out of state right away.\n\n    \nlocal\n \ncurrentTime\n \n=\n \nself\n.\nstate\n.\ncurrentTime\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- Set up our loop in didMount, so that it starts running when our\n\n\n-- component is created.\n\n\nfunction\n \nClock\n:\ndidMount\n()\n\n    \n-- Set a value that we can change later to stop our loop\n\n    \nself\n.\nrunning\n \n=\n \ntrue\n\n\n    \n-- We don't want to block the main thread, so we spawn a new one!\n\n    \nspawn\n(\nfunction\n()\n\n        \nwhile\n \nself\n.\nrunning\n \ndo\n\n            \n-- Because we depend on the previous state, we use the function\n\n            \n-- variant of setState. This will matter more when Roact gets\n\n            \n-- asynchronous rendering!\n\n            \nself\n:\nsetState\n(\nfunction\n(\nstate\n)\n\n                \nreturn\n \n{\n\n                    \ncurrentTime\n \n=\n \nstate\n.\ncurrentTime\n \n+\n \n1\n\n                \n}\n\n            \nend\n)\n\n\n            \nwait\n(\n1\n)\n\n        \nend\n\n    \nend\n)\n\n\nend\n\n\n\n-- Stop the loop in willUnmount, so that our loop terminates when the\n\n\n-- component is destroyed.\n\n\nfunction\n \nClock\n:\nwillUnmount\n()\n\n    \nself\n.\nrunning\n \n=\n \nfalse\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our UI, which now runs on its own!\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nRoact\n.\ncreateElement\n(\nClock\n),\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n-- Later, we can destroy our UI and disconnect everything correctly.\n\n\nwait\n(\n10\n)\n\n\nRoact\n.\nteardown\n(\nhandle\n)",
            "title": "State and Lifecycle"
        },
        {
            "location": "/guide/state-and-lifecycle/#state-and-lifecycle",
            "text": "In the previous section, we talked about using components to create reusable chunks of state, and introduced  functional  and  stateful  components.  Stateful components do everything that functional components do, but have the addition of mutable  state  and  lifecycle methods .",
            "title": "State and Lifecycle"
        },
        {
            "location": "/guide/state-and-lifecycle/#state",
            "text": "Info  This section is incomplete!",
            "title": "State"
        },
        {
            "location": "/guide/state-and-lifecycle/#lifecycle-methods",
            "text": "Stateful components can provide methods to Roact that are called when certain things happen to a component instance.  Lifecycle methods are a great place to send off network requests, measure UI ( with the help of refs ), wrap non-Roact components, and produce other side-effects.  Mounting:  \n     init \n     \u279d \n     render \n     \u279d \n     didMount   Updating:  \n     shouldUpdate? \n     \u279d \n     getDerivedStateFromProps \n     \u279d \n     willUpdate \n     \u279d \n     render \n     \u279d \n     didUpdate   Unmounting:  \n     willUnmount",
            "title": "Lifecycle Methods"
        },
        {
            "location": "/guide/state-and-lifecycle/#incrementing-counter-part-three",
            "text": "Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use  setState  to trigger a re-render instead of  Roact.reconcile .  Generally, this ticking clock demonstrates how many stateful components are structured in Roact.  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   Clock   =   Roact . Component : extend ( \"Clock\" )  function   Clock : init () \n     -- In init, you should assign to 'state' directly. \n     -- Use this opportunity to set any initial values. \n     self . state   =   { \n         currentTime   =   0 \n     }  end  -- This render function is almost completely unchanged from the first example.  function   Clock : render () \n     -- As a convention, we'll pull currentTime out of state right away. \n     local   currentTime   =   self . state . currentTime \n\n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  -- Set up our loop in didMount, so that it starts running when our  -- component is created.  function   Clock : didMount () \n     -- Set a value that we can change later to stop our loop \n     self . running   =   true \n\n     -- We don't want to block the main thread, so we spawn a new one! \n     spawn ( function () \n         while   self . running   do \n             -- Because we depend on the previous state, we use the function \n             -- variant of setState. This will matter more when Roact gets \n             -- asynchronous rendering! \n             self : setState ( function ( state ) \n                 return   { \n                     currentTime   =   state . currentTime   +   1 \n                 } \n             end ) \n\n             wait ( 1 ) \n         end \n     end )  end  -- Stop the loop in willUnmount, so that our loop terminates when the  -- component is destroyed.  function   Clock : willUnmount () \n     self . running   =   false  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our UI, which now runs on its own!  local   handle   =   Roact . reify ( Roact . createElement ( Clock ),   PlayerGui ,   \"Clock UI\" )  -- Later, we can destroy our UI and disconnect everything correctly.  wait ( 10 )  Roact . teardown ( handle )",
            "title": "Incrementing Counter, Part Three"
        },
        {
            "location": "/guide/events/",
            "text": "Events\n\u00b6\n\n\nRoact manages Instance event connections automatically as part of rendering.\n\n\nTo connect to an event, pass a prop with \nRoact.Event.EVENT_NAME\n as the key and a function as the value.\n\n\nRoact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in.\n\n\nlocal\n \nbutton\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n    \nText\n \n=\n \n\"Click me!\"\n,\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n\n    \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"The button was clicked!\"\n)\n\n    \nend\n\n\n})\n\n\n\n\n\n\n\nInfo\n\n\nEvents will automatically be disconnected when a component instance is unmounted!",
            "title": "Events"
        },
        {
            "location": "/guide/events/#events",
            "text": "Roact manages Instance event connections automatically as part of rendering.  To connect to an event, pass a prop with  Roact.Event.EVENT_NAME  as the key and a function as the value.  Roact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in.  local   button   =   Roact . createElement ( \"TextButton\" ,   { \n     Text   =   \"Click me!\" , \n     Size   =   UDim2 . new ( 0 ,   400 ,   0 ,   300 ), \n\n     [ Roact . Event . MouseButton1Click ]   =   function ( rbx ) \n         print ( \"The button was clicked!\" ) \n     end  })    Info  Events will automatically be disconnected when a component instance is unmounted!",
            "title": "Events"
        },
        {
            "location": "/advanced/portals/",
            "text": "Portals\n\u00b6\n\n\nPortals\n are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance.\n\n\n\n\nInfo\n\n\nEventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game, \nPortal\n.\n\n\n\n\nTo create a portal, use the \nRoact.Portal\n component with \ncreateElement\n:\n\n\nlocal\n \nfunction\n \nPartInWorkspace\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\nRoact\n.\nPortal\n,\n \n{\n\n        \ntarget\n \n=\n \nWorkspace\n\n    \n},\n \n{\n\n        \nSomePart\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Part\"\n,\n \n{\n\n            \nAnchored\n \n=\n \ntrue\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n\n\nWhen we create \nPartInWorkspace\n, even if it's deep into our Roact tree, a \nPart\n Instance named \nSomePart\n will be created in \nWorkspace\n.\n\n\n\n\nWarning\n\n\nPortals should only be created to objects that aren't managed by Roact!\n\n\n\n\nOne particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them!\n\n\nlocal\n \nPlayerGui\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n).\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Our Modal component is a standard component, but with a portal at the top!\n\n\nlocal\n \nfunction\n \nModal\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\nRoact\n.\nPortal\n,\n \n{\n\n        \ntarget\n \n=\n \nPlayerGui\n\n    \n},\n \n{\n\n        \nModal\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n            \nLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n                \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n                \nText\n \n=\n \n\"Click me to close!\"\n,\n\n\n                \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nfunction\n()\n\n                    \nprops\n.\nonClose\n()\n\n                \nend\n\n            \n})\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- A ModalButton contains a little bit of state to decide whether the dialog\n\n\n-- should be open or not.\n\n\nlocal\n \nModalButton\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"ModalButton\"\n)\n\n\n\nfunction\n \nModalButton\n:\ninit\n()\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \ndialogOpen\n \n=\n \nfalse\n\n    \n}\n\n\nend\n\n\n\nfunction\n \nModalButton\n:\nrender\n()\n\n    \nlocal\n \ndialog\n \n=\n \nnil\n\n\n    \n-- If the dialog isn't open, just avoid rendering it.\n\n    \nif\n \nself\n.\nstate\n.\ndialogOpen\n \nthen\n\n        \ndialog\n \n=\n \nRoact\n.\ncreateElement\n(\nModal\n,\n \n{\n\n            \nonClose\n \n=\n \nfunction\n()\n\n                \nself\n:\nsetState\n({\n\n                    \ndialogOpen\n \n=\n \nfalse\n\n                \n})\n\n            \nend\n\n        \n})\n\n    \nend\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n        \nText\n \n=\n \n\"Click me to open modal dialog!\"\n,\n\n\n        \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nfunction\n()\n\n            \nself\n:\nsetState\n({\n\n                \ndialogOpen\n \n=\n \ntrue\n\n            \n})\n\n        \nend\n\n    \n},\n \n{\n\n        \n-- If `dialog` ends up nil, this line does nothing!\n\n        \nDialog\n \n=\n \ndialog\n\n    \n})\n\n\nend",
            "title": "Portals"
        },
        {
            "location": "/advanced/portals/#portals",
            "text": "Portals  are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance.   Info  Eventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game,  Portal .   To create a portal, use the  Roact.Portal  component with  createElement :  local   function   PartInWorkspace ( props ) \n     return   Roact . createElement ( Roact . Portal ,   { \n         target   =   Workspace \n     },   { \n         SomePart   =   Roact . createElement ( \"Part\" ,   { \n             Anchored   =   true \n         }) \n     })  end   When we create  PartInWorkspace , even if it's deep into our Roact tree, a  Part  Instance named  SomePart  will be created in  Workspace .   Warning  Portals should only be created to objects that aren't managed by Roact!   One particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them!  local   PlayerGui   =   game : GetService ( \"Players\" ). LocalPlayer . PlayerGui  -- Our Modal component is a standard component, but with a portal at the top!  local   function   Modal ( props ) \n     return   Roact . createElement ( Roact . Portal ,   { \n         target   =   PlayerGui \n     },   { \n         Modal   =   Roact . createElement ( \"ScreenGui\" ,   {},   { \n             Label   =   Roact . createElement ( \"TextButton\" ,   { \n                 Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n                 Text   =   \"Click me to close!\" , \n\n                 [ Roact . Event . Activated ]   =   function () \n                     props . onClose () \n                 end \n             }) \n         }) \n     })  end  -- A ModalButton contains a little bit of state to decide whether the dialog  -- should be open or not.  local   ModalButton   =   Roact . Component : extend ( \"ModalButton\" )  function   ModalButton : init () \n     self . state   =   { \n         dialogOpen   =   false \n     }  end  function   ModalButton : render () \n     local   dialog   =   nil \n\n     -- If the dialog isn't open, just avoid rendering it. \n     if   self . state . dialogOpen   then \n         dialog   =   Roact . createElement ( Modal ,   { \n             onClose   =   function () \n                 self : setState ({ \n                     dialogOpen   =   false \n                 }) \n             end \n         }) \n     end \n\n     return   Roact . createElement ( \"TextButton\" ,   { \n         Size   =   UDim2 . new ( 0 ,   400 ,   0 ,   300 ), \n         Text   =   \"Click me to open modal dialog!\" , \n\n         [ Roact . Event . Activated ]   =   function () \n             self : setState ({ \n                 dialogOpen   =   true \n             }) \n         end \n     },   { \n         -- If `dialog` ends up nil, this line does nothing! \n         Dialog   =   dialog \n     })  end",
            "title": "Portals"
        },
        {
            "location": "/advanced/refs/",
            "text": "Refs\n\u00b6\n\n\nRefs\n grant access to the actual Instance objects that are created by Roact. They're an escape hatch for when something is difficult or impossible to correctly express with the Roact API.\n\n\n\n\nInfo\n\n\nRefs can only be used with primitive components.\n\n\n\n\nRefs in Action\n\u00b6\n\n\nTo create a ref, pass a function prop with the key \nRoact.Ref\n when creating a primitive element.\n\n\nFor example, suppose we wanted to create a search bar that captured cursor focus when any part of it was clicked. We might use a component like this:\n\n\n--[[\n\n\n    A search bar with an icon and a text box that captures focus for its TextBox\n\n\n    when its icon is clicked\n\n\n ]]\n\n\nlocal\n \nSearchBar\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"SearchBar\"\n)\n\n\n\nfunction\n \nSearchBar\n:\nrender\n()\n\n    \n-- Render our icon and text box side by side in a Frame\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n200\n,\n \n0\n,\n \n20\n),\n\n    \n},\n \n{\n\n        \nSearchIcon\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ImageButton\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n20\n,\n \n0\n,\n \n20\n),\n\n            \n-- Handle click events on the icon\n\n            \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n()\n\n\n                \n-- If our capture method is defined, trigger it\n\n                \nif\n \nself\n.\ncaptureTextboxFocus\n \nthen\n\n                    \nself\n.\ncaptureTextboxFocus\n()\n\n                \nend\n\n            \nend\n\n        \n}),\n\n\n        \nSearchTextBox\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextBox\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n180\n,\n \n0\n,\n \n20\n),\n\n            \nPosition\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n20\n,\n \n0\n,\n \n0\n),\n\n            \n-- We use Roact.Ref to get a reference to the underlying object\n\n            \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n\n                \n-- Set a callback function to give focus to the TextBox\n\n                \nself\n.\ncaptureTextboxFocus\n \n=\n \nfunction\n()\n\n                    \nrbx\n:\nCaptureFocus\n()\n\n                \nend\n\n            \nend\n\n        \n}),\n\n    \n})\n\n\nend\n\n\n\nWhen a user clicks on the outer \nImageButton\n, the \ncaptureTextboxFocus\n callback will be triggered and the \nTextBox\n instance will get focus as if it had been clicked on directly.\n\n\n\n\nWarning\n\n\nWhen a component instance is destroyed or the ref property changes, \nnil\n will be passed to the old ref function!\n\n\n\n\nlocal\n \nframe\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"Ref was called with\"\n,\n \nrbx\n,\n \n\"of type\"\n,\n \ntypeof\n(\nrbx\n))\n\n    \nend\n\n\n})\n\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nframe\n)\n\n\n\n-- Output:\n\n\n--     Ref was called with Frame of type Instance\n\n\n\nRoact\n.\nteardown\n(\nhandle\n)\n\n\n\n-- In the output:\n\n\n--     Ref was called with nil of type nil",
            "title": "Refs"
        },
        {
            "location": "/advanced/refs/#refs",
            "text": "Refs  grant access to the actual Instance objects that are created by Roact. They're an escape hatch for when something is difficult or impossible to correctly express with the Roact API.   Info  Refs can only be used with primitive components.",
            "title": "Refs"
        },
        {
            "location": "/advanced/refs/#refs-in-action",
            "text": "To create a ref, pass a function prop with the key  Roact.Ref  when creating a primitive element.  For example, suppose we wanted to create a search bar that captured cursor focus when any part of it was clicked. We might use a component like this:  --[[      A search bar with an icon and a text box that captures focus for its TextBox      when its icon is clicked   ]]  local   SearchBar   =   Roact . Component : extend ( \"SearchBar\" )  function   SearchBar : render () \n     -- Render our icon and text box side by side in a Frame \n     return   Roact . createElement ( \"Frame\" ,   { \n         Size   =   UDim2 . new ( 0 ,   200 ,   0 ,   20 ), \n     },   { \n         SearchIcon   =   Roact . createElement ( \"ImageButton\" ,   { \n             Size   =   UDim2 . new ( 0 ,   20 ,   0 ,   20 ), \n             -- Handle click events on the icon \n             [ Roact . Event . MouseButton1Click ]   =   function () \n\n                 -- If our capture method is defined, trigger it \n                 if   self . captureTextboxFocus   then \n                     self . captureTextboxFocus () \n                 end \n             end \n         }), \n\n         SearchTextBox   =   Roact . createElement ( \"TextBox\" ,   { \n             Size   =   UDim2 . new ( 0 ,   180 ,   0 ,   20 ), \n             Position   =   UDim2 . new ( 0 ,   20 ,   0 ,   0 ), \n             -- We use Roact.Ref to get a reference to the underlying object \n             [ Roact . Ref ]   =   function ( rbx ) \n\n                 -- Set a callback function to give focus to the TextBox \n                 self . captureTextboxFocus   =   function () \n                     rbx : CaptureFocus () \n                 end \n             end \n         }), \n     })  end  \nWhen a user clicks on the outer  ImageButton , the  captureTextboxFocus  callback will be triggered and the  TextBox  instance will get focus as if it had been clicked on directly.   Warning  When a component instance is destroyed or the ref property changes,  nil  will be passed to the old ref function!   local   frame   =   Roact . createElement ( \"Frame\" ,   { \n     [ Roact . Ref ]   =   function ( rbx ) \n         print ( \"Ref was called with\" ,   rbx ,   \"of type\" ,   typeof ( rbx )) \n     end  })  local   handle   =   Roact . reify ( frame )  -- Output:  --     Ref was called with Frame of type Instance  Roact . teardown ( handle )  -- In the output:  --     Ref was called with nil of type nil",
            "title": "Refs in Action"
        },
        {
            "location": "/advanced/context/",
            "text": "Context\n\u00b6\n\n\n\n\nWarning\n\n\nContext is an unstable feature that's being \nsignificantly\n revised. See \nissue #4\n for current progress.\n\n\n\n\n\n\nInfo\n\n\nThis section is incomplete. It's possible that the context API will change before the existing API is ever documented.",
            "title": "Context"
        },
        {
            "location": "/advanced/context/#context",
            "text": "Warning  Context is an unstable feature that's being  significantly  revised. See  issue #4  for current progress.    Info  This section is incomplete. It's possible that the context API will change before the existing API is ever documented.",
            "title": "Context"
        },
        {
            "location": "/performance/overview/",
            "text": "Performance Guide\n\u00b6\n\n\nRoact operates on the principle that it's much easier to build UI declaratively. When something changes, the UI is rebuilt virtually and then the minimal necessary changes are made to the actual UI elements.\n\n\nFor simple projects, performance is unlikely to be an issue. But Roact is built in Lua, and Lua can be slow. The following pages provide a number of techniques and best practices that you can employ to avoid performance strain with your Roact apps.",
            "title": "Overview"
        },
        {
            "location": "/performance/overview/#performance-guide",
            "text": "Roact operates on the principle that it's much easier to build UI declaratively. When something changes, the UI is rebuilt virtually and then the minimal necessary changes are made to the actual UI elements.  For simple projects, performance is unlikely to be an issue. But Roact is built in Lua, and Lua can be slow. The following pages provide a number of techniques and best practices that you can employ to avoid performance strain with your Roact apps.",
            "title": "Performance Guide"
        },
        {
            "location": "/performance/reduce-reconciliation/",
            "text": "Reduce Reconciliation\n\u00b6\n\n\nIn all likelihood, the primary source of performance gains for your app will come from reducing the amount of work that Roact's reconcilation process requires. This is accomplished by:\n\n\n\n\nIndicating to Roact that some reconciliation work can be skipped\n\n\nMaking sure your elements only change in ways you intended\n\n\n\n\nshouldUpdate\n Lifecycle Method\n\u00b6\n\n\nWhen a Roact Component's state or props change, it will call the Component's \nshouldUpdate\n method to determine whether or not to re-render it. The default implementation will always return true.\n\nfunction\n \nComponent\n:\nshouldUpdate\n(\nnewProps\n,\n \nnewState\n)\n\n    \nreturn\n \ntrue\n\n\nend\n\n\n\n\nIf you have a more complex component that only needs to re-render in certain situations, you can either use \nPureComponent\n (discussed below) or implement your own \nshouldUpdate\n and return \nfalse\n in any case where an update is not required.\n\n\n\n\nWarning\n\n\nManually implementing \nshouldUpdate\n is \ndangerous\n! If done carelessly, it can easily create confusing or subtle bugs.\n\n\nIn most cases, the preferable solution is to use \nPureComponent\n instead, which has a simple and robust implementation of \nshouldUpdate\n.\n\n\n\n\nPureComponent\n\u00b6\n\n\nOne common implementation of \nshouldUpdate\n is to do a shallow comparison between current and previous props and state. \nRoact\n provides an extension of \nRoact.Component\n called \nRoact.PureComponent\n that uses this implementation.\n\n\nLet's use the following example:\n\nlocal\n \nItem\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Item\"\n)\n\n\n\nfunction\n \nItem\n:\nrender\n()\n\n    \nlocal\n \nicon\n \n=\n \nself\n.\nprops\n.\nicon\n\n    \nlocal\n \nlayoutOrder\n \n=\n \nself\n.\nprops\n.\nlayoutOrder\n\n\n    \n-- Create a list item with the item's icon and name\n\n    \nRoact\n.\ncreateElement\n(\n\"ImageLabel\"\n,\n \n{\n\n        \nLayoutOrder\n \n=\n \nlayoutOrder\n,\n\n        \nImage\n \n=\n \nicon\n,\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nInventory\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Inventory\"\n)\n\n\n\nfunction\n \nInventory\n:\nrender\n()\n\n    \n-- An Inventory contains a list of items\n\n    \nlocal\n \nitems\n \n=\n \nself\n.\nstate\n.\nitems\n\n\n    \nlocal\n \nitemList\n \n=\n \n{}\n\n    \n-- Create a UIListLayout to space out our items\n\n    \nitemList\n[\n\"Layout\"\n]\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n,\n \n{\n\n        \nSortOrder\n \n=\n \nEnum\n.\nSortOrder\n.\nLayoutOrder\n,\n\n        \nFillDirection\n \n=\n \nEnum\n.\nFillDirection\n.\nVertical\n,\n\n    \n})\n\n    \nfor\n \ni\n,\n \nitem\n \nin\n \nipairs\n(\nitems\n)\n \ndo\n\n        \n-- Add the element to our list\n\n        \nitemList\n[\ni\n]\n \n=\n \nRoact\n.\ncreateElement\n(\nItem\n,\n \n{\n\n            \nlayoutOrder\n \n=\n \ni\n,\n\n            \nicon\n \n=\n \nitem\n.\nicon\n,\n\n        \n})\n\n    \nend\n\n\n    \n-- The Inventory renders a frame containing the list of Items as children\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n200\n,\n \n0\n,\n \n400\n)\n\n    \n},\n \nitemList\n)\n\n\nend\n\n\n\n\nIn the above example, adding a new item to the \nitems\n prop of the \nInventory\n would cause all of the child \nItem\n elements to re-render, even if they haven't changed at all. This means if you add an item to an \nInventory\n that already has 5 items, the result will be 6 renders of the \nItem\n component.\n\n\nLets change \nItem\n to a \nPureComponent\n:\n\nlocal\n \nItem\n \n=\n \nRoact\n.\nPureComponent\n:\nextend\n(\n\"Item\"\n)\n\n\n\nNow, if we add a new item to the end of the \nInventory\n or change something about an existing item, we'll only re-render the \nInventory\n itself and the modified \nItem\n!\n\n\n\n\nWarning\n\n\nWhen working with \nPureComponent\n, it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change. \n\n\n\n\n\n\nInfo\n\n\nThere's more to discuss about immutability. It deserves a fully fleshed-out section somewhere!\n\n\n\n\nStable Keys\n\u00b6\n\n\nAnother performance improvement we can make is to use stable, unique keys to refer to our child elements.\n\n\nWhen the list that we pass into the \nInventory\n component changes, Roact reconciles our Roblox UI by adjusting the properties of each primitive according to the new list of elements.\n\n\nFor example, let's suppose our list of items is as follows:\n\n{\n\n    \n{\n \nid\n \n=\n \n\"sword\"\n,\n \nicon\n \n=\n \nswordIcon\n \n},\n \n-- [1]\n\n    \n{\n \nid\n \n=\n \n\"shield\"\n,\n \nicon\n \n=\n \nshieldIcon\n \n},\n \n-- [2]\n\n\n}\n\n\n\n\nIf we add a new item to the beginning, then we'll end up with a list like this:\n\n{\n \n    \n{\n \nid\n \n=\n \n\"potion\"\n,\n \nicon\n \n=\n \npotionIcon\n \n}\n \n-- [1]\n\n    \n{\n \nid\n \n=\n \n\"sword\"\n,\n \nicon\n \n=\n \nswordIcon\n \n},\n \n-- [2]\n\n    \n{\n \nid\n \n=\n \n\"shield\"\n,\n \nicon\n \n=\n \nshieldIcon\n \n},\n \n-- [3]\n\n\n}\n\n\n\n\nWhen Roact reconciles the underlying \nImageLabel\n objects, it will need to change their icons so that the item at \n[1]\n has the potion icon, the item at \n[2]\n has the sword icon, and a new \nImageLabel\n is added at \n[3]\n with the shield icon.\n\n\nWe'd like for Roact to know that the new item was added at \n[1]\n and that the sword and sheild items simply moved down in the list. Then it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest.\n\n\nSo let's fix it! We'll make our list of \nItem\n elements use the item's id for its keys instead of the indexes in the \nitems\n list:\n\n\nfunction\n \nInventory\n:\nrender\n()\n\n    \n-- An Inventory contains a list of items\n\n    \nlocal\n \nitems\n \n=\n \nself\n.\nstate\n.\nitems\n\n\n    \nlocal\n \nitemList\n \n=\n \n{}\n\n    \nitemList\n[\n\"Layout\"\n]\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n,\n \n{\n\n        \nSortOrder\n \n=\n \nEnum\n.\nSortOrder\n.\nLayoutOrder\n,\n\n        \nFillDirection\n \n=\n \nEnum\n.\nFillDirection\n.\nVertical\n,\n\n    \n})\n\n    \nfor\n \ni\n,\n \nitem\n \nin\n \nipairs\n(\nitems\n)\n \ndo\n\n\n        \n-- Each element is now added at a stable key\n\n\n        \nitemList\n[\nitem\n.\nid\n]\n \n=\n \nRoact\n.\ncreateElement\n(\nItem\n,\n \n{\n\n\n            \nlayoutOrder\n \n=\n \ni\n,\n\n            \nicon\n \n=\n \nitem\n.\nicon\n,\n\n        \n})\n\n    \nend\n\n\n    \n-- The Inventory renders a frame containing the list of Items as children\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n200\n,\n \n0\n,\n \n400\n)\n\n    \n},\n \nitemList\n)\n\n\nend\n\n\n\n\n\nNow the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be reconciled. When we add the third element to the list, Roact will set the \nLayoutOrder\n property on for each \nImageLabel\n and only set the \nImage\n property on the newly added one!\n\n\n\n\nInfo\n\n\nSwitching to static keys might seem insignificant for \nthis\n example, but if our \nItem\n component becomes more complicated and our inventory gets bigger, it can make a significant difference!",
            "title": "Reduce Reconcilation"
        },
        {
            "location": "/performance/reduce-reconciliation/#reduce-reconciliation",
            "text": "In all likelihood, the primary source of performance gains for your app will come from reducing the amount of work that Roact's reconcilation process requires. This is accomplished by:   Indicating to Roact that some reconciliation work can be skipped  Making sure your elements only change in ways you intended",
            "title": "Reduce Reconciliation"
        },
        {
            "location": "/performance/reduce-reconciliation/#shouldupdate-lifecycle-method",
            "text": "When a Roact Component's state or props change, it will call the Component's  shouldUpdate  method to determine whether or not to re-render it. The default implementation will always return true. function   Component : shouldUpdate ( newProps ,   newState ) \n     return   true  end   If you have a more complex component that only needs to re-render in certain situations, you can either use  PureComponent  (discussed below) or implement your own  shouldUpdate  and return  false  in any case where an update is not required.   Warning  Manually implementing  shouldUpdate  is  dangerous ! If done carelessly, it can easily create confusing or subtle bugs.  In most cases, the preferable solution is to use  PureComponent  instead, which has a simple and robust implementation of  shouldUpdate .",
            "title": "shouldUpdate Lifecycle Method"
        },
        {
            "location": "/performance/reduce-reconciliation/#purecomponent",
            "text": "One common implementation of  shouldUpdate  is to do a shallow comparison between current and previous props and state.  Roact  provides an extension of  Roact.Component  called  Roact.PureComponent  that uses this implementation.  Let's use the following example: local   Item   =   Roact . Component : extend ( \"Item\" )  function   Item : render () \n     local   icon   =   self . props . icon \n     local   layoutOrder   =   self . props . layoutOrder \n\n     -- Create a list item with the item's icon and name \n     Roact . createElement ( \"ImageLabel\" ,   { \n         LayoutOrder   =   layoutOrder , \n         Image   =   icon , \n     })  end  local   Inventory   =   Roact . Component : extend ( \"Inventory\" )  function   Inventory : render () \n     -- An Inventory contains a list of items \n     local   items   =   self . state . items \n\n     local   itemList   =   {} \n     -- Create a UIListLayout to space out our items \n     itemList [ \"Layout\" ]   =   Roact . createElement ( \"UIListLayout\" ,   { \n         SortOrder   =   Enum . SortOrder . LayoutOrder , \n         FillDirection   =   Enum . FillDirection . Vertical , \n     }) \n     for   i ,   item   in   ipairs ( items )   do \n         -- Add the element to our list \n         itemList [ i ]   =   Roact . createElement ( Item ,   { \n             layoutOrder   =   i , \n             icon   =   item . icon , \n         }) \n     end \n\n     -- The Inventory renders a frame containing the list of Items as children \n     return   Roact . createElement ( \"Frame\" ,   { \n         Size   =   UDim2 . new ( 0 ,   200 ,   0 ,   400 ) \n     },   itemList )  end   In the above example, adding a new item to the  items  prop of the  Inventory  would cause all of the child  Item  elements to re-render, even if they haven't changed at all. This means if you add an item to an  Inventory  that already has 5 items, the result will be 6 renders of the  Item  component.  Lets change  Item  to a  PureComponent : local   Item   =   Roact . PureComponent : extend ( \"Item\" )  \nNow, if we add a new item to the end of the  Inventory  or change something about an existing item, we'll only re-render the  Inventory  itself and the modified  Item !   Warning  When working with  PureComponent , it's critical to use immutable props. Immutability guarantees that a prop's reference will change any time its contents change.     Info  There's more to discuss about immutability. It deserves a fully fleshed-out section somewhere!",
            "title": "PureComponent"
        },
        {
            "location": "/performance/reduce-reconciliation/#stable-keys",
            "text": "Another performance improvement we can make is to use stable, unique keys to refer to our child elements.  When the list that we pass into the  Inventory  component changes, Roact reconciles our Roblox UI by adjusting the properties of each primitive according to the new list of elements.  For example, let's suppose our list of items is as follows: { \n     {   id   =   \"sword\" ,   icon   =   swordIcon   },   -- [1] \n     {   id   =   \"shield\" ,   icon   =   shieldIcon   },   -- [2]  }   If we add a new item to the beginning, then we'll end up with a list like this: {  \n     {   id   =   \"potion\" ,   icon   =   potionIcon   }   -- [1] \n     {   id   =   \"sword\" ,   icon   =   swordIcon   },   -- [2] \n     {   id   =   \"shield\" ,   icon   =   shieldIcon   },   -- [3]  }   When Roact reconciles the underlying  ImageLabel  objects, it will need to change their icons so that the item at  [1]  has the potion icon, the item at  [2]  has the sword icon, and a new  ImageLabel  is added at  [3]  with the shield icon.  We'd like for Roact to know that the new item was added at  [1]  and that the sword and sheild items simply moved down in the list. Then it can adjust their LayoutOrder properties and let the Roblox UI system resolve the rest.  So let's fix it! We'll make our list of  Item  elements use the item's id for its keys instead of the indexes in the  items  list:  function   Inventory : render () \n     -- An Inventory contains a list of items \n     local   items   =   self . state . items \n\n     local   itemList   =   {} \n     itemList [ \"Layout\" ]   =   Roact . createElement ( \"UIListLayout\" ,   { \n         SortOrder   =   Enum . SortOrder . LayoutOrder , \n         FillDirection   =   Enum . FillDirection . Vertical , \n     }) \n     for   i ,   item   in   ipairs ( items )   do           -- Each element is now added at a stable key           itemList [ item . id ]   =   Roact . createElement ( Item ,   {               layoutOrder   =   i , \n             icon   =   item . icon , \n         }) \n     end \n\n     -- The Inventory renders a frame containing the list of Items as children \n     return   Roact . createElement ( \"Frame\" ,   { \n         Size   =   UDim2 . new ( 0 ,   200 ,   0 ,   400 ) \n     },   itemList )  end   Now the list of children is keyed by the stable, unique id of the item data. Their positions can change according to their LayoutOrder, but no other properties on the item need to be reconciled. When we add the third element to the list, Roact will set the  LayoutOrder  property on for each  ImageLabel  and only set the  Image  property on the newly added one!   Info  Switching to static keys might seem insignificant for  this  example, but if our  Item  component becomes more complicated and our inventory gets bigger, it can make a significant difference!",
            "title": "Stable Keys"
        },
        {
            "location": "/api-reference/",
            "text": "Roact API Reference\n\u00b6\n\n\nMethods\n\u00b6\n\n\nRoact.createElement\n\u00b6\n\n\nRoact.createElement(component, [props, [children]]) -> RoactElement\n\n\n\n\nCreates a new Roact element representing the given \ncomponent\n.\n\n\nThe \nchildren\n argument is shorthand for adding a \nRoact.Children\n key to \nprops\n. It should be specified as a dictionary of names to elements.\n\n\ncomponent\n can be a string, a function, or a table created by \nComponent:extend\n.\n\n\n\n\nCaution\n\n\nOnce \nprops\n or \nchildren\n are passed into the \ncreateElement\n, make sure not to modify them!\n\n\n\n\nRoact.reify\n\u00b6\n\n\nRoact.reify(element, [parent, [key]]) -> ComponentInstanceHandle\n\n\n\n\nCreates a Roblox Instance given a Roact element, and optionally a \nparent\n to put it in, and a \nkey\n to use as the instance's \nName\n.\n\n\nThe result is a \nComponentInstanceHandle\n, which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like \nRoact.teardown\n and the future debug API.\n\n\nRoact.reconcile\n\u00b6\n\n\nRoact.reconcile(instanceHandle, element) -> ComponentInstanceHandle\n\n\n\n\nUpdates an existing instance handle with a new element, returning a new handle.\n\n\nreconcile\n can be used to change the props of a component instance created with \nreify\n and is useful for putting Roact content into non-Roact applications.\n\n\n\n\nWarning\n\n\nRoact.reconcile\n takes ownership of the \ninstanceHandle\n passed into it and may tear it down and create a new tree!\n\n\nMake sure to use the handle that \nreconcile\n returns in any operations after \nreconcile\n, including \nteardown\n.\n\n\n\n\nRoact.teardown\n\u00b6\n\n\nRoact.teardown(instance) -> void\n\n\n\n\nDestroys the given \nComponentInstanceHandle\n and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by \nRoact.reify\n.\n\n\nRoact.oneChild\n\u00b6\n\n\nRoact.oneChild(children) -> RoactElement | nil\n\n\nGiven a dictionary of children, returns a single child element.\n\n\nIf \nchildren\n contains more than one child, \noneChild\n function will throw an error. This is intended to denote an error when using the component using \noneChild\n.\n\n\nIf \nchildren\n is \nnil\n or contains no children, \noneChild\n will return \nnil\n.\n\n\nConstants\n\u00b6\n\n\nRoact.Children\n\u00b6\n\n\nThis is the key that Roact uses internally to store the children that are attached to a Roact element.\n\n\nIf you're writing a new functional or stateful element that needs to be used like a primitive component, you can access \nRoact.Children\n in your props table.\n\n\nRoact.Ref\n\u00b6\n\n\nUse \nRoact.Ref\n as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance.\n\n\nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"Roblox Instance\"\n,\n \nrbx\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\n\nWarning\n\n\nRoact.Ref\n will be called with \nnil\n when the component instance is destroyed!\n\n\n\n\nSee \nthe refs guide\n for more details.\n\n\nRoact.Event\n\u00b6\n\n\nIndex into \nRoact.Event\n to receive a key that can be used to connect to events when creating primitive elements:\n\n\nRoact\n.\ncreateElement\n(\n\"ImageButton\"\n,\n \n{\n\n    \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n(\nrbx\n,\n \nx\n,\n \ny\n)\n\n        \nprint\n(\nrbx\n,\n \n\"clicked at position\"\n,\n \nx\n,\n \ny\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\n\nInfo\n\n\nEvent callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.\n\n\n\n\n\n\nWarning\n\n\nWhen connecting to the \nChanged\n event, be careful not to call \nsetState\n or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown!\n\n\n\n\nSee \nthe events guide\n for more details.\n\n\nRoact.Change\n\u00b6\n\n\nIndex into \nRoact.Change\n to receive a key that can be used to connect to \nGetPropertyChangedSignal\n events.\n\n\nIt's similar to \nRoact.Event\n:\n\n\nRoact\n.\ncreateElement\n(\n\"ScrollingFrame\"\n,\n \n{\n\n    \n[\nRoact\n.\nChange\n.\nCanvasPosition\n]\n \n=\n \nfunction\n(\nrbx\n,\n \nposition\n)\n\n        \nprint\n(\n\"ScrollingFrame scrolled to\"\n,\n \nposition\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\n\nWarning\n\n\nProperty changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown!\n\n\n\n\nComponent Types\n\u00b6\n\n\nRoact.Component\n\u00b6\n\n\nThe base component instance that can be extended to make stateful components.\n\n\nCall \nRoact.Component:extend(\"ComponentName\")\n to make a new stateful component with a given name.\n\n\nRoact.PureComponent\n\u00b6\n\n\nAn extension of \nRoact.Component\n that only re-renders if its props or state change.\n\n\nPureComponent\n implements the \nshouldUpdate\n lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux.\n\n\nPureComponent\n is not \nalways\n faster, but can often result in significant performance improvements when used correctly.\n\n\nRoact.Portal\n\u00b6\n\n\nA component that represents a \nportal\n to a Roblox Instance. Portals are created using \nRoact.createElement\n.\n\n\nAny children of a portal are put inside the Roblox Instance specified by the required \ntarget\n prop. That Roblox Instance should not be one created by Roact.\n\n\nPortals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once.\n\n\nSee \nthe Portals guide\n for a small tutorial and more details about portals.\n\n\nComponent API\n\u00b6\n\n\ninit\n\u00b6\n\n\ninit(initialProps) -> void\n\n\n\n\ninit\n is called exactly once when a new instance of a component is created. It can be used to set up the initial \nstate\n, as well as any non-\nrender\n related values directly on the component.\n\n\ninit\n is the only place where you can assign to \nstate\n directly, as opposed to using \nsetState\n:\n\n\nfunction\n \nMyComponent\n:\ninit\n()\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \nposition\n \n=\n \n0\n,\n\n        \nvelocity\n \n=\n \n10\n\n    \n}\n\n\nend\n\n\n\n\n\nrender\n\u00b6\n\n\nrender() -> Element | nil\n\n\n\n\nrender\n describes what a component should display at the current instant in time.\n\n\n\n\nInfo\n\n\nRoact assumes that \nrender\n act likes a pure function: the result of \nrender\n must depend only on \nprops\n and \nstate\n, and it must not have side-effects.\n\n\n\n\nfunction\n \nMyComponent\n:\nrender\n()\n\n    \n-- This is okay:\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \nself\n.\nprops\n.\ntext\n,\n\n        \nPosition\n \n=\n \nself\n.\nstate\n.\nposition\n\n    \n})\n\n\n    \n-- Ack! Depending on values outside props/state is not allowed!\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \nself\n.\nsomeText\n,\n\n        \nPosition\n \n=\n \ngetMousePosition\n(),\n\n    \n})\n\n\nend\n\n\n\n\n\nrender\n must be defined for all components. The default implementation of \nrender\n throws an error; if your component does not render anything, define a render function that returns \nnil\n explicitly.\n\n\nfunction\n \nMyComponent\n:\nrender\n()\n\n    \nreturn\n \nnil\n\n\nend\n\n\n\n\n\nsetState\n\u00b6\n\n\nsetState(newState) -> void\n\n\n\n\nsetState\n merges a table of new state values (\nnewState\n) onto the existing \nstate\n and re-renders the component if necessary. Existing values are not affected.\n\n\nfunction\n \nMyComponent\n:\ndidMount\n()\n\n    \nself\n:\nsetState\n({\n\n        \nfoo\n \n=\n \n\"bar\"\n\n    \n})\n\n\nend\n\n\n\n\n\n\n\nWarning\n\n\nCalling \nsetState\n from any of these places is not allowed and will throw an error:\n\n\n\n\nLifecycle hooks: \nwillUpdate\n, \nwillUnmount\n\n\nInitialization: \ninit\n\n\nPure functions: \nrender\n, \nshouldUpdate\n\n\n\n\n\n\n\n\nFuture API Changes\n\n\nDepending on current \nstate\n in \nsetState\n may cause subtle bugs when Roact starts supporting \nasynchronous rendering\n.\n\n\nA new API similar to React \nis being introduced\n to solve this problem. This documentation will be updated when that API is released.\n\n\n\n\nshouldUpdate\n\u00b6\n\n\nshouldUpdate(nextProps, nextState) -> bool\n\n\n\n\nshouldUpdate\n provides a way to override Roact's rerendering heuristics.\n\n\nRight now, components are re-rendered any time a parent component updates, or when state is updated via \nsetState\n.\n\n\nPureComponent\n implements \nshouldUpdate\n to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, \nall\n components may implement this check by default.\n\n\nLifecycle Methods\n\u00b6\n\n\nIn addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process.\n\n\nA \ndiagram of Roact's lifecycle methods\n can be found in the guide.\n\n\ndidMount\n\u00b6\n\n\ndidMount() -> void\n\n\n\n\ndidMount\n is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting.\n\n\ndidMount\n is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.\n\n\nwillUnmount\n\u00b6\n\n\nwillUnmount() -> void\n\n\n\n\nwillUnmount\n is fired right before Roact begins tearing down a component instance's children.\n\n\nwillUnmount\n acts like a component's destructor, and is a good place to disconnect any manually-connected events.\n\n\nwillUpdate\n\u00b6\n\n\nwillUpdate(nextProps, nextState) -> void\n\n\n\n\nwillUpdate\n is fired after an update is started but before a component's state and props are updated.\n\n\ndidUpdate\n\u00b6\n\n\ndidUpdate(previousProps, previousState) -> void\n\n\n\n\ndidUpdate\n is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date.\n\n\ndidUpdate\n is a good place to send network requests or dispatch Rodux actions, but make sure to compare \nself.props\n and \nself.state\n with \npreviousProps\n and \npreviousState\n to avoid triggering too many updates.\n\n\ngetDerivedStateFromProps\n\u00b6\n\n\nstatic getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice\n\n\n\n\nUsed to recalculate any state that depends on being synchronized with \nprops\n.\n\n\nGenerally, you should use \ndidUpdate\n to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead.\n\n\ngetDerivedStateFromProps\n should return a table that contains the part of the state that should be updated.\n\n\nfunction\n \nMyComponent\n.\ngetDerivedStateFromProps\n(\nnextProps\n,\n \nlastState\n)\n\n    \nreturn\n \n{\n\n        \nsomeValue\n \n=\n \nnextProps\n.\nsomeValue\n\n    \n}\n\n\nend\n\n\n\n\n\n\n\nNote\n\n\ngetDerivedStateFromProps\n is a \nstatic\n lifecycle method. It does not have access to \nself\n, and must be a pure function.",
            "title": "API Reference"
        },
        {
            "location": "/api-reference/#roact-api-reference",
            "text": "",
            "title": "Roact API Reference"
        },
        {
            "location": "/api-reference/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api-reference/#roactcreateelement",
            "text": "Roact.createElement(component, [props, [children]]) -> RoactElement  Creates a new Roact element representing the given  component .  The  children  argument is shorthand for adding a  Roact.Children  key to  props . It should be specified as a dictionary of names to elements.  component  can be a string, a function, or a table created by  Component:extend .   Caution  Once  props  or  children  are passed into the  createElement , make sure not to modify them!",
            "title": "Roact.createElement"
        },
        {
            "location": "/api-reference/#roactreify",
            "text": "Roact.reify(element, [parent, [key]]) -> ComponentInstanceHandle  Creates a Roblox Instance given a Roact element, and optionally a  parent  to put it in, and a  key  to use as the instance's  Name .  The result is a  ComponentInstanceHandle , which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like  Roact.teardown  and the future debug API.",
            "title": "Roact.reify"
        },
        {
            "location": "/api-reference/#roactreconcile",
            "text": "Roact.reconcile(instanceHandle, element) -> ComponentInstanceHandle  Updates an existing instance handle with a new element, returning a new handle.  reconcile  can be used to change the props of a component instance created with  reify  and is useful for putting Roact content into non-Roact applications.   Warning  Roact.reconcile  takes ownership of the  instanceHandle  passed into it and may tear it down and create a new tree!  Make sure to use the handle that  reconcile  returns in any operations after  reconcile , including  teardown .",
            "title": "Roact.reconcile"
        },
        {
            "location": "/api-reference/#roactteardown",
            "text": "Roact.teardown(instance) -> void  Destroys the given  ComponentInstanceHandle  and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by  Roact.reify .",
            "title": "Roact.teardown"
        },
        {
            "location": "/api-reference/#roactonechild",
            "text": "Roact.oneChild(children) -> RoactElement | nil  Given a dictionary of children, returns a single child element.  If  children  contains more than one child,  oneChild  function will throw an error. This is intended to denote an error when using the component using  oneChild .  If  children  is  nil  or contains no children,  oneChild  will return  nil .",
            "title": "Roact.oneChild"
        },
        {
            "location": "/api-reference/#constants",
            "text": "",
            "title": "Constants"
        },
        {
            "location": "/api-reference/#roactchildren",
            "text": "This is the key that Roact uses internally to store the children that are attached to a Roact element.  If you're writing a new functional or stateful element that needs to be used like a primitive component, you can access  Roact.Children  in your props table.",
            "title": "Roact.Children"
        },
        {
            "location": "/api-reference/#roactref",
            "text": "Use  Roact.Ref  as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance.  Roact . createElement ( \"Frame\" ,   { \n     [ Roact . Ref ]   =   function ( rbx ) \n         print ( \"Roblox Instance\" ,   rbx ) \n     end ,  })    Warning  Roact.Ref  will be called with  nil  when the component instance is destroyed!   See  the refs guide  for more details.",
            "title": "Roact.Ref"
        },
        {
            "location": "/api-reference/#roactevent",
            "text": "Index into  Roact.Event  to receive a key that can be used to connect to events when creating primitive elements:  Roact . createElement ( \"ImageButton\" ,   { \n     [ Roact . Event . MouseButton1Click ]   =   function ( rbx ,   x ,   y ) \n         print ( rbx ,   \"clicked at position\" ,   x ,   y ) \n     end ,  })    Info  Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.    Warning  When connecting to the  Changed  event, be careful not to call  setState  or other functions that will trigger renders. This will cause Roact to re-render during a render, and errors will be thrown!   See  the events guide  for more details.",
            "title": "Roact.Event"
        },
        {
            "location": "/api-reference/#roactchange",
            "text": "Index into  Roact.Change  to receive a key that can be used to connect to  GetPropertyChangedSignal  events.  It's similar to  Roact.Event :  Roact . createElement ( \"ScrollingFrame\" ,   { \n     [ Roact . Change . CanvasPosition ]   =   function ( rbx ,   position ) \n         print ( \"ScrollingFrame scrolled to\" ,   position ) \n     end ,  })    Warning  Property changed events are fired by Roact during the reconciliation phase. Be careful not to accidentally trigger a re-render in the middle of a re-render, or an error will be thrown!",
            "title": "Roact.Change"
        },
        {
            "location": "/api-reference/#component-types",
            "text": "",
            "title": "Component Types"
        },
        {
            "location": "/api-reference/#roactcomponent",
            "text": "The base component instance that can be extended to make stateful components.  Call  Roact.Component:extend(\"ComponentName\")  to make a new stateful component with a given name.",
            "title": "Roact.Component"
        },
        {
            "location": "/api-reference/#roactpurecomponent",
            "text": "An extension of  Roact.Component  that only re-renders if its props or state change.  PureComponent  implements the  shouldUpdate  lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux.  PureComponent  is not  always  faster, but can often result in significant performance improvements when used correctly.",
            "title": "Roact.PureComponent"
        },
        {
            "location": "/api-reference/#roactportal",
            "text": "A component that represents a  portal  to a Roblox Instance. Portals are created using  Roact.createElement .  Any children of a portal are put inside the Roblox Instance specified by the required  target  prop. That Roblox Instance should not be one created by Roact.  Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once.  See  the Portals guide  for a small tutorial and more details about portals.",
            "title": "Roact.Portal"
        },
        {
            "location": "/api-reference/#component-api",
            "text": "",
            "title": "Component API"
        },
        {
            "location": "/api-reference/#init",
            "text": "init(initialProps) -> void  init  is called exactly once when a new instance of a component is created. It can be used to set up the initial  state , as well as any non- render  related values directly on the component.  init  is the only place where you can assign to  state  directly, as opposed to using  setState :  function   MyComponent : init () \n     self . state   =   { \n         position   =   0 , \n         velocity   =   10 \n     }  end",
            "title": "init"
        },
        {
            "location": "/api-reference/#render",
            "text": "render() -> Element | nil  render  describes what a component should display at the current instant in time.   Info  Roact assumes that  render  act likes a pure function: the result of  render  must depend only on  props  and  state , and it must not have side-effects.   function   MyComponent : render () \n     -- This is okay: \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   self . props . text , \n         Position   =   self . state . position \n     }) \n\n     -- Ack! Depending on values outside props/state is not allowed! \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   self . someText , \n         Position   =   getMousePosition (), \n     })  end   render  must be defined for all components. The default implementation of  render  throws an error; if your component does not render anything, define a render function that returns  nil  explicitly.  function   MyComponent : render () \n     return   nil  end",
            "title": "render"
        },
        {
            "location": "/api-reference/#setstate",
            "text": "setState(newState) -> void  setState  merges a table of new state values ( newState ) onto the existing  state  and re-renders the component if necessary. Existing values are not affected.  function   MyComponent : didMount () \n     self : setState ({ \n         foo   =   \"bar\" \n     })  end    Warning  Calling  setState  from any of these places is not allowed and will throw an error:   Lifecycle hooks:  willUpdate ,  willUnmount  Initialization:  init  Pure functions:  render ,  shouldUpdate     Future API Changes  Depending on current  state  in  setState  may cause subtle bugs when Roact starts supporting  asynchronous rendering .  A new API similar to React  is being introduced  to solve this problem. This documentation will be updated when that API is released.",
            "title": "setState"
        },
        {
            "location": "/api-reference/#shouldupdate",
            "text": "shouldUpdate(nextProps, nextState) -> bool  shouldUpdate  provides a way to override Roact's rerendering heuristics.  Right now, components are re-rendered any time a parent component updates, or when state is updated via  setState .  PureComponent  implements  shouldUpdate  to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update,  all  components may implement this check by default.",
            "title": "shouldUpdate"
        },
        {
            "location": "/api-reference/#lifecycle-methods",
            "text": "In addition to the base Component API, Roact exposes additional lifecycle methods that stateful components can hook into to be notified of various steps in the rendering process.  A  diagram of Roact's lifecycle methods  can be found in the guide.",
            "title": "Lifecycle Methods"
        },
        {
            "location": "/api-reference/#didmount",
            "text": "didMount() -> void  didMount  is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting.  didMount  is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.",
            "title": "didMount"
        },
        {
            "location": "/api-reference/#willunmount",
            "text": "willUnmount() -> void  willUnmount  is fired right before Roact begins tearing down a component instance's children.  willUnmount  acts like a component's destructor, and is a good place to disconnect any manually-connected events.",
            "title": "willUnmount"
        },
        {
            "location": "/api-reference/#willupdate",
            "text": "willUpdate(nextProps, nextState) -> void  willUpdate  is fired after an update is started but before a component's state and props are updated.",
            "title": "willUpdate"
        },
        {
            "location": "/api-reference/#didupdate",
            "text": "didUpdate(previousProps, previousState) -> void  didUpdate  is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date.  didUpdate  is a good place to send network requests or dispatch Rodux actions, but make sure to compare  self.props  and  self.state  with  previousProps  and  previousState  to avoid triggering too many updates.",
            "title": "didUpdate"
        },
        {
            "location": "/api-reference/#getderivedstatefromprops",
            "text": "static getDerivedStateFromProps(nextProps, lastState) -> nextStateSlice  Used to recalculate any state that depends on being synchronized with  props .  Generally, you should use  didUpdate  to respond to props changing. If you find yourself copying props values to state as-is, consider using props or memoization instead.  getDerivedStateFromProps  should return a table that contains the part of the state that should be updated.  function   MyComponent . getDerivedStateFromProps ( nextProps ,   lastState ) \n     return   { \n         someValue   =   nextProps . someValue \n     }  end    Note  getDerivedStateFromProps  is a  static  lifecycle method. It does not have access to  self , and must be a pure function.",
            "title": "getDerivedStateFromProps"
        }
    ]
}